## 算法要点

解题思路：

- 如果是未旋转的有序数组，则可以直接使用二分查找找到target
- 可以将已旋转的数组变换为未旋转数组。但是，如果变动数组，将会产生O(N)的复杂度，不如直接遍历查找
- 可以找到最小值的位置，通过坐标映射，题目转换为对未旋转数组的查找
- 考虑最小值坐标是否可以通过二分查找获得

## 二分查找最小值的下标

因为找最小值下标的时候，会用到左边、右边的值，所以这里选择使用左闭右闭的区间。

即查找的坐标范围是[left, right]，所以初始条件是：

```
left = 0
right = len(nums) - 1
```

查找的过程就是不断的迭代更新left和right的过程。

针对初始化的数组和更新区间的数组，考虑以下几种情况：

第一种情况：`left_value <= right_value` 数组是个单调递增，即未旋转的，最小值坐标就是left。
第一种情况中，还包含了`[2]`这种长度为1的数组的情况，可以直接返回。

除了第一种情况外，都有`left_value > right_value`。

第二种情况：如果数组里边只有两个值了，则最小值坐标是right。比如数组[3, 2]，最小值是2，坐标是right。

除了第一、第二种情况外，其他情况都有`left_value > right_value`且数组中至少3个值。

第三种情况：如果`mid_value > left_value`，意味着左半部分的值都大于右半部分的值，最小值落在右侧，且不可能是`mid_value`。可将`left = mid + 1`缩小区间。

第四种情况：是第三种情况的的其他情况，即`mid_value < left_value`，最小值落在右侧，因为`mid_value`可能是最小值，所以新的区间应该包含mid，使用`right = mid`缩小区间。


## 坐标映射

最小值的值映射到未旋转的数组的0位置。反过来，未旋转的坐标映射成旋转后的坐标，以获得对应的数值：

```python
def get_rotated_index(self, index):
    return (index + self.smallest_value_index) % len(self.nums)
```
